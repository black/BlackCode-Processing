<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- NewPage -->
<html lang="es">
<head>
<!-- Generated by javadoc (version 1.7.0_65) on Sat Sep 20 10:08:24 COT 2014 -->
<title>Eye (Javadocs: proscene)</title>
<meta name="date" content="2014-09-20">
<link rel="stylesheet" type="text/css" href="../../../stylesheet.css" title="Style">
</head>
<body>
<script type="text/javascript"><!--
    if (location.href.indexOf('is-external=true') == -1) {
        parent.document.title="Eye (Javadocs: proscene)";
    }
//-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a name="navbar_top">
<!--   -->
</a><a href="#skip-navbar_top" title="Skip navigation links"></a><a name="navbar_top_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../remixlab/dandelion/core/Constants.WheelAction.html" title="enum in remixlab.dandelion.core"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?remixlab/dandelion/core/Eye.html" target="_top">Frames</a></li>
<li><a href="Eye.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
<!-- ======== START OF CLASS DATA ======== -->
<div class="header">
<div class="subTitle">remixlab.dandelion.core</div>
<h2 title="Class Eye" class="title">Class Eye</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">java.lang.Object</a></li>
<li>
<ul class="inheritance">
<li>remixlab.dandelion.core.Eye</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>All Implemented Interfaces:</dt>
<dd><a href="../../../remixlab/util/Copyable.html" title="interface in remixlab.util">Copyable</a></dd>
</dl>
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><a href="../../../remixlab/dandelion/core/Camera.html" title="class in remixlab.dandelion.core">Camera</a>, <a href="../../../remixlab/dandelion/core/Window.html" title="class in remixlab.dandelion.core">Window</a></dd>
</dl>
<hr>
<br>
<pre>public abstract class <span class="strong">Eye</span>
extends <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>
implements <a href="../../../remixlab/util/Copyable.html" title="interface in remixlab.util">Copyable</a></pre>
<div class="block">Abstract base class for 3D <a href="../../../remixlab/dandelion/core/Camera.html" title="class in remixlab.dandelion.core"><code>Camera</code></a>s and 2D <a href="../../../remixlab/dandelion/core/Window.html" title="class in remixlab.dandelion.core"><code>Window</code></a>s.
 <p>
 An Eye defines some intrinsic parameters (<a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a>...) and
 useful positioning tools that ease its placement (<a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()"><code>showEntireScene()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a>...). It exports its associated projection and view matrices and it can interactively be modified
 using any interaction mechanism you can think of (see <a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core"><code>InteractiveEyeFrame</code></a> class).
 <p>
 An Eye holds a collection of paths (<a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int key)</code></a>) each of which can be interpolated (
 <a href="../../../remixlab/dandelion/core/Eye.html#playPath(int)"><code>playPath(int)</code></a>). It also provides visibility routines (<a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>), from which advanced geometry culling
 techniques can be implemented.
 <p>
 The <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> of the Eye are defined by an
 <a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core"><code>InteractiveEyeFrame</code></a> (retrieved using <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a>). These methods are just
 convenient wrappers to the equivalent Frame methods. This also means that the Eye <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a> can be attached to
 a <a href="../../../remixlab/dandelion/core/Frame.html#referenceFrame()"><code>Frame.referenceFrame()</code></a> which enables complex Eye setups. An Eye has its own
 magnitude, different from that of the scene (i.e., <a href="../../../remixlab/dandelion/core/Frame.html#magnitude()"><code>Frame.magnitude()</code></a> doesn't
 necessarily equals <code>1</code>), which allows to scale the view. Use <a href="../../../remixlab/dandelion/core/Eye.html#eyeCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>eyeCoordinatesOf(Vec)</code></a> and
 <a href="../../../remixlab/dandelion/core/Eye.html#worldCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>worldCoordinatesOf(Vec)</code></a> (or any of the powerful Frame transformations, such as
 <a href="../../../remixlab/dandelion/core/Frame.html#coordinatesOf(remixlab.dandelion.geom.Vec)"><code>Frame.coordinatesOf(Vec)</code></a>, <a href="../../../remixlab/dandelion/core/Frame.html#transformOf(remixlab.dandelion.geom.Vec)"><code>Frame.transformOf(Vec)</code></a>,
 ...) to convert to and from the Eye <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a> coordinate system. <a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>projectedCoordinatesOf(Vec)</code></a> and
 <a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>unprojectedCoordinatesOf(Vec)</code></a> will convert from screen to 3D coordinates.
 <p>
 An Eye can also be used outside of an Scene for its coordinate system conversion capabilities.</div>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- ======== NESTED CLASS SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="nested_class_summary">
<!--   -->
</a>
<h3>Nested Class Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Nested Class Summary table, listing nested classes, and an explanation">
<caption><span>Nested Classes</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Class and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static class&nbsp;</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core">Eye.Visibility</a></strong></code>
<div class="block">Enumerates the different visibility states an object may have respect to the Eye boundary.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- =========== FIELD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Field Summary table, listing fields, and an explanation">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Field and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#lastNonFrameUpdate">lastNonFrameUpdate</a></strong></code>
<div class="block">Which was the last frame the Eye changes.</div>
</td>
</tr>
</table>
</li>
</ul>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Constructor Summary table, listing constructors, and an explanation">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colOne" scope="col">Constructor and Description</th>
</tr>
<tr class="altColor">
<td class="colOne"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#Eye(remixlab.dandelion.core.AbstractScene)">Eye</a></strong>(<a href="../../../remixlab/dandelion/core/AbstractScene.html" title="class in remixlab.dandelion.core">AbstractScene</a>&nbsp;scn)</code>&nbsp;</td>
</tr>
</table>
</li>
</ul>
<!-- ========== METHOD SUMMARY =========== -->
<ul class="blockList">
<li class="blockList"><a name="method_summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="overviewSummary" border="0" cellpadding="3" cellspacing="0" summary="Method Summary table, listing methods, and an explanation">
<caption><span>Methods</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colLast" scope="col">Method and Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#addKeyFrameToPath(int)">addKeyFrameToPath</a></strong>(int&nbsp;key)</code>
<div class="block">Adds the current Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> as a keyFrame to path <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#anchor()">anchor</a></strong>()</code>
<div class="block">The point the Eye revolves around with the ROTATE action binding.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#anyInterpolationIsStarted()">anyInterpolationIsStarted</a></strong>()</code>
<div class="block"><strong>Deprecated.</strong>&nbsp;
<div class="block"><i>Please refrain from using this method, it will be removed from future releases.</i></div>
</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#anyInterpolationStarted()">anyInterpolationStarted</a></strong>()</code>
<div class="block">Returns <code>true</code> if any interpolation associated with this Eye is currently being performed (and <code>false</code>
 otherwise).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#areBoundaryEquationsEnabled()">areBoundaryEquationsEnabled</a></strong>()</code>
<div class="block">Returns <code>true</code> if automatic update of the eye boundary plane equations is enabled and <code>false</code>
 otherwise.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#aspectRatio()">aspectRatio</a></strong>()</code>
<div class="block">Returns the Eye aspect ratio defined by <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> / <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#at()">at</a></strong>()</code>
<div class="block">2D Windows return the postion. 3D Cameras return a point defined in the world coordinate system where the camera is
 pointing at (just in front of <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a>).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract <a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core">Eye.Visibility</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)">ballVisibility</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center,
              float&nbsp;radius)</code>
<div class="block">Returns <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#VISIBLE"><code>Eye.Visibility.VISIBLE</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#INVISIBLE"><code>Eye.Visibility.INVISIBLE</code></a>, or
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#SEMIVISIBLE"><code>Eye.Visibility.SEMIVISIBLE</code></a>, depending whether the sphere (of radius <code>radius</code>
 and center <code>center</code>) is visible, invisible, or semi-visible, respectively.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract <a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core">Eye.Visibility</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)">boxVisibility</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;p1,
             <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;p2)</code>
<div class="block">Returns <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#VISIBLE"><code>Eye.Visibility.VISIBLE</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#INVISIBLE"><code>Eye.Visibility.INVISIBLE</code></a>, or
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#SEMIVISIBLE"><code>Eye.Visibility.SEMIVISIBLE</code></a>, depending whether the axis aligned box (defined by
 corners <code>p1</code> and <code>p2</code>) is visible, invisible, or semi-visible, respectively.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#centerScene()">centerScene</a></strong>()</code>
<div class="block">Moves the Eye so that its <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> is projected on the center of the window.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract float[][]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()">computeBoundaryEquations</a></strong>()</code>
<div class="block">Convenience function that in 2D simply returns <code>computeFrustumPlanesCoefficients(new float [4][3])</code> and in 3D
 <code>computeFrustumPlanesCoefficients(new float [6][4])</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract float[][]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations(float[][])">computeBoundaryEquations</a></strong>(float[][]&nbsp;coef)</code>
<div class="block">Fills <code>coef</code> with the 6 plane equations of the camera frustum and returns it.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#computeProjection()">computeProjection</a></strong>()</code>
<div class="block">Computes the projection matrix associated with the Eye.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#computeView()">computeView</a></strong>()</code>
<div class="block">Computes the View matrix associated with the Eye's <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#deletePath(int)">deletePath</a></strong>(int&nbsp;key)</code>
<div class="block">Deletes the <a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int)</code></a> of index <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#distanceToAnchor()">distanceToAnchor</a></strong>()</code>
<div class="block">Returns the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> distance in Scene units.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)">distanceToBoundary</a></strong>(int&nbsp;index,
                  <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;pos)</code>
<div class="block">Returns the signed distance between point <code>pos</code> and plane <code>index</code> in Scene units.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#distanceToSceneCenter()">distanceToSceneCenter</a></strong>()</code>
<div class="block">Returns the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> distance in Scene units.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#enableBoundaryEquations(boolean)">enableBoundaryEquations</a></strong>(boolean&nbsp;flag)</code>
<div class="block">Enables or disables automatic update of the eye boundary plane equations every frame according to <code>flag</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#equals(java.lang.Object)">equals</a></strong>(<a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;obj)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#eyeCoordinatesOf(remixlab.dandelion.geom.Vec)">eyeCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Returns the Eye frame coordinates of a point <code>src</code> defined in world coordinates.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)">fitBall</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center,
       float&nbsp;radius)</code>
<div class="block">Moves the Eye so that the ball defined by <code>center</code> and <code>radius</code> is visible and fits the window.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#fitBoundingBox(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)">fitBoundingBox</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;min,
              <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;max)</code>
<div class="block">Moves the Eye so that the (world axis aligned) bounding box (<code>min</code> , <code>max</code>) is entirely visible, using
 <a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#fitScreenRegion(remixlab.dandelion.geom.Rect)">fitScreenRegion</a></strong>(<a href="../../../remixlab/dandelion/geom/Rect.html" title="class in remixlab.dandelion.geom">Rect</a>&nbsp;rectangle)</code>
<div class="block">Moves the Eye so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the
 upper left corner) fits the screen.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#flip()">flip</a></strong>()</code>
<div class="block">Same as <code>scene.flip()</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#flySpeed()">flySpeed</a></strong>()</code>
<div class="block">Returns the fly speed of the Eye.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core">InteractiveEyeFrame</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#frame()">frame</a></strong>()</code>
<div class="block">Returns the InteractiveEyeFrame attached to the Eye.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#fromView(remixlab.dandelion.geom.Mat)">fromView</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;mv)</code>
<div class="block">Convenience function that simply calls <code>fromView(mv, true)</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#fromView(remixlab.dandelion.geom.Mat,%20boolean)">fromView</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;mv,
        boolean&nbsp;recompute)</code>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> from an OpenGL-like View matrix.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract <a href="../../../remixlab/dandelion/core/Eye.html" title="class in remixlab.dandelion.core">Eye</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#get()">get</a></strong>()</code>
<div class="block">Returns a deep copy of the object.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>float[][]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()">getBoundaryEquations</a></strong>()</code>
<div class="block">Returns the boundary plane equations.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>float[]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryWidthHeight()">getBoundaryWidthHeight</a></strong>()</code>
<div class="block">Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>float[]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryWidthHeight(float[])">getBoundaryWidthHeight</a></strong>(float[]&nbsp;target)</code>
<div class="block">Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code> of the Eye boundary and returns it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getProjection()">getProjection</a></strong>()</code>
<div class="block">Convenience function that simply returns <code>getProjectionMatrix(false)</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(boolean)">getProjection</a></strong>(boolean&nbsp;recompute)</code>
<div class="block">Convenience function that simply returns <code>getProjection(new Mat(), recompute)</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat)">getProjection</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m)</code>
<div class="block">Convenience function that simply returns <code>getProjection(m, false)</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)">getProjection</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m,
             boolean&nbsp;recompute)</code>
<div class="block">Fills <code>m</code> with the Eye projection matrix values and returns it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getView()">getView</a></strong>()</code>
<div class="block">Convenience function that simply returns <code>getViewMatrix(false)</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getView(boolean)">getView</a></strong>(boolean&nbsp;recompute)</code>
<div class="block">Convenience function that simply returns <code>getViewMatrix(new Mat(), recompute)</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat)">getView</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m)</code>
<div class="block">Convenience function that simply returns <code>getViewMatrix(m, false)</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat,%20boolean)">getView</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m,
       boolean&nbsp;recompute)</code>
<div class="block">Fills <code>m</code> with the Eye View matrix values and returns it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getViewport()">getViewport</a></strong>()</code>
<div class="block">Convenience function that simply calls <code>return</code> <a href="../../../remixlab/dandelion/core/Eye.html#getViewport(int[])"><code>getViewport(int[])</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int[]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#getViewport(int[])">getViewport</a></strong>(int[]&nbsp;vp)</code>
<div class="block">Fills <code>viewport</code> with the Eye viewport and returns it.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#hashCode()">hashCode</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#interpolateTo(remixlab.dandelion.core.Frame)">interpolateTo</a></strong>(<a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;fr)</code>
<div class="block">Convenience function that simply calls <code>interpolateTo(fr, 1)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#interpolateTo(remixlab.dandelion.core.Frame,%20float)">interpolateTo</a></strong>(<a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;fr,
             float&nbsp;duration)</code>
<div class="block">Smoothly interpolates the Eye on a KeyFrameInterpolator path so that it goes to <code>fr</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#interpolateToFitScene()">interpolateToFitScene</a></strong>()</code>
<div class="block">Interpolates the Eye on a one second KeyFrameInterpolator path so that the entire scene fits the screen at the end.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#interpolateToZoomOnPixel(remixlab.dandelion.geom.Point)">interpolateToZoomOnPixel</a></strong>(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</code>
<div class="block">Makes the Eye smoothly zoom on the <a href="../../../remixlab/dandelion/core/Camera.html#pointUnderPixel(remixlab.dandelion.geom.Point)"><code>Camera.pointUnderPixel(Point)</code></a> <code>pixel</code> and
 returns the world coordinates of the <a href="../../../remixlab/dandelion/core/Camera.html#pointUnderPixel(remixlab.dandelion.geom.Point)"><code>Camera.pointUnderPixel(Point)</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#interpolateToZoomOnRegion(remixlab.dandelion.geom.Rect)">interpolateToZoomOnRegion</a></strong>(<a href="../../../remixlab/dandelion/geom/Rect.html" title="class in remixlab.dandelion.geom">Rect</a>&nbsp;rectangle)</code>
<div class="block">Smoothly moves the Eye so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin
 in the upper left corner) fits the screen.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)">isPointVisible</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;point)</code>
<div class="block">Returns <code>true</code> if <code>point</code> is visible (i.e, lies within the Eye boundary) and <code>false</code> otherwise.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)">keyFrameInterpolator</a></strong>(int&nbsp;key)</code>
<div class="block">Returns the KeyFrameInterpolator that defines the Eye path number <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>[]</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolatorArray()">keyFrameInterpolatorArray</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="http://java.sun.com/javase/7/docs/api/java/util/HashMap.html?is-external=true" title="class or interface in java.util">HashMap</a>&lt;<a href="http://java.sun.com/javase/7/docs/api/java/lang/Integer.html?is-external=true" title="class or interface in java.lang">Integer</a>,<a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>&gt;</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolatorMap()">keyFrameInterpolatorMap</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#lastNonFrameUpdate()">lastNonFrameUpdate</a></strong>()</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>long</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#lastUpdate()">lastUpdate</a></strong>()</code>
<div class="block">Max between <a href="../../../remixlab/dandelion/core/Frame.html#lastUpdate()"><code>Frame.lastUpdate()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#lastNonFrameUpdate()"><code>lastNonFrameUpdate()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)">lookAt</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;target)</code>
<div class="block">2D Windows simply call <code>frame().setPosition(target.x(), target.y())</code>. 3D Cameras set <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>,
 so that it looks at point <code>target</code> defined in the world coordinate system (The Camera <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> is
 not modified.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Rotation.html" title="interface in remixlab.dandelion.geom">Rotation</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#orientation()">orientation</a></strong>()</code>
<div class="block">Returns the Eye orientation, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#pixelSceneRatio(remixlab.dandelion.geom.Vec)">pixelSceneRatio</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;position)</code>
<div class="block">Returns the ratio between pixel and scene units at <code>position</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#playPath(int)">playPath</a></strong>(int&nbsp;key)</code>
<div class="block">Makes the Eye follow the path of keyFrameInterpolator() number <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#position()">position</a></strong>()</code>
<div class="block">Returns the Eye position, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#project(float,%20float,%20float,%20float[])">project</a></strong>(float&nbsp;objx,
       float&nbsp;objy,
       float&nbsp;objz,
       float[]&nbsp;windowCoordinate)</code>
<div class="block">Similar to <code>gluProject</code>: map object coordinates to window coordinates.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#project(remixlab.dandelion.geom.Mat,%20float,%20float,%20float,%20float[])">project</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projectionViewMat,
       float&nbsp;objx,
       float&nbsp;objy,
       float&nbsp;objz,
       float[]&nbsp;windowCoordinate)</code>&nbsp;</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Mat,%20remixlab.dandelion.geom.Vec)">projectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projview,
                      <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(projview, src, null)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Mat,%20remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)">projectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projview,
                      <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                      <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</code>
<div class="block">Returns the screen projected coordinates of a point <code>src</code> defined in the <code>frame</code> coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec)">projectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(src, null)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)">projectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                      <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</code>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(null, src, frame)</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#resetPath(int)">resetPath</a></strong>(int&nbsp;key)</code>
<div class="block">Resets the path of the <a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int)</code></a> number <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#rightVector()">rightVector</a></strong>()</code>
<div class="block">Returns the normalized right vector of the Eye, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#rotationSensitivity()">rotationSensitivity</a></strong>()</code>
<div class="block">Convenience wrapper function that simply returns <code>frame().rotationSensitivity()</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()">sceneCenter</a></strong>()</code>
<div class="block">Returns the position of the scene center, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()">sceneRadius</a></strong>()</code>
<div class="block">Returns the radius of the scene observed by the Eye in scene (world) units.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()">screenHeight</a></strong>()</code>
<div class="block">Returns the height (in pixels) of the Eye screen.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>int</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()">screenWidth</a></strong>()</code>
<div class="block">Returns the width (in pixels) of the Eye screen.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setAnchor(remixlab.dandelion.geom.Vec)">setAnchor</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;rap)</code>
<div class="block">Changes the <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> to <code>rap</code> (defined in the world coordinate system).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setAnchorFromPixel(remixlab.dandelion.geom.Point)">setAnchorFromPixel</a></strong>(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</code>
<div class="block">The <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> is set to the point located under <code>pixel</code> on screen.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setAspectRatio(float)">setAspectRatio</a></strong>(float&nbsp;aspect)</code>
<div class="block">Defines the Eye <a href="../../../remixlab/dandelion/core/Eye.html#aspectRatio()"><code>aspectRatio()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setFlySpeed(float)">setFlySpeed</a></strong>(float&nbsp;speed)</code>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#flySpeed()"><code>flySpeed()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setFrame(remixlab.dandelion.core.InteractiveEyeFrame)">setFrame</a></strong>(<a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core">InteractiveEyeFrame</a>&nbsp;icf)</code>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setKeyFrameInterpolator(int,%20remixlab.dandelion.core.KeyFrameInterpolator)">setKeyFrameInterpolator</a></strong>(int&nbsp;key,
                       <a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>&nbsp;keyFInterpolator)</code>
<div class="block">Sets the KeyFrameInterpolator that defines the Eye path of index <code>key</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)">setOrientation</a></strong>(<a href="../../../remixlab/dandelion/geom/Rotation.html" title="interface in remixlab.dandelion.geom">Rotation</a>&nbsp;q)</code>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setPosition(remixlab.dandelion.geom.Vec)">setPosition</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;pos)</code>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> (the eye), defined in the world coordinate system.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[])">setProjection</a></strong>(float[]&nbsp;source)</code>
<div class="block">Convenience function that simply calls <code>setProjectionMatrix(source, false)</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[],%20boolean)">setProjection</a></strong>(float[]&nbsp;source,
             boolean&nbsp;transpose)</code>
<div class="block">Fills the projection matrix with the <code>source</code> matrix values (defined in row-major order).</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(remixlab.dandelion.geom.Mat)">setProjection</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;proj)</code>
<div class="block">Fills the projection matrix with the <code>proj</code> matrix values.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setRotationSensitivity(float)">setRotationSensitivity</a></strong>(float&nbsp;sensitivity)</code>
<div class="block">Convenience wrapper function that simply calls <code>frame().setRotationSensitivity(sensitivity)</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setSceneBoundingBox(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)">setSceneBoundingBox</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;min,
                   <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;max)</code>
<div class="block">Similar to <a href="../../../remixlab/dandelion/core/Eye.html#setSceneRadius(float)"><code>setSceneRadius(float)</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenter(remixlab.dandelion.geom.Vec)"><code>setSceneCenter(Vec)</code></a>, but the scene limits are defined by a
 (world axis aligned) bounding box.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenter(remixlab.dandelion.geom.Vec)">setSceneCenter</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center)</code>
<div class="block">Sets the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenterFromPixel(remixlab.dandelion.geom.Point)">setSceneCenterFromPixel</a></strong>(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</code>
<div class="block">The <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> is set to the point located under <code>pixel</code> on screen.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setSceneRadius(float)">setSceneRadius</a></strong>(float&nbsp;radius)</code>
<div class="block">Sets the <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a> value in scene (world) units.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setScreenWidthAndHeight(int,%20int)">setScreenWidthAndHeight</a></strong>(int&nbsp;width,
                       int&nbsp;height)</code>
<div class="block">Sets Eye <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a> (expressed in pixels).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setSpinningSensitivity(float)">setSpinningSensitivity</a></strong>(float&nbsp;sensitivity)</code>
<div class="block">Convenience wrapper function that simply calls <code>frame().setSpinningSensitivity(sensitivity)</code></div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setTranslationSensitivity(float)">setTranslationSensitivity</a></strong>(float&nbsp;sensitivity)</code>
<div class="block">Convenience wrapper function that simply calls <code>frame().setTranslationSensitivity(sensitivity)</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec)">setUpVector</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;up)</code>
<div class="block">Convenience function that simply calls <code>setUpVector(up, true)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec,%20boolean)">setUpVector</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;up,
           boolean&nbsp;noMove)</code>
<div class="block">Rotates the Eye so that its <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a> becomes <code>up</code> (defined in the world coordinate system).</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>abstract void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()">showEntireScene</a></strong>()</code>
<div class="block">Moves the Eye so that the entire scene is visible.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#spinningSensitivity()">spinningSensitivity</a></strong>()</code>
<div class="block">Convenience wrapper function that simply returns <code>frame().spinningSensitivity()</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#stopAllInterpolations()">stopAllInterpolations</a></strong>()</code>
<div class="block">Stops all interpolations currently being performed associated with this Eye.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>float</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#translationSensitivity()">translationSensitivity</a></strong>()</code>
<div class="block">Convenience wrapper function that simply returns <code>frame().translationSensitivity()</code></div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unproject(float,%20float,%20float,%20float[])">unproject</a></strong>(float&nbsp;winx,
         float&nbsp;winy,
         float&nbsp;winz,
         float[]&nbsp;objCoordinate)</code>&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unproject(remixlab.dandelion.geom.Mat,%20float,%20float,%20float,%20float[])">unproject</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projectionViewInverseMat,
         float&nbsp;winx,
         float&nbsp;winy,
         float&nbsp;winz,
         float[]&nbsp;objCoordinate)</code>
<div class="block">Similar to <code>gluUnProject</code>: map window coordinates to object coordinates.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Mat,%20remixlab.dandelion.geom.Vec)">unprojectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projviewInv,
                        <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(projviewInv, src, null)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Mat,%20remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)">unprojectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projviewInv,
                        <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                        <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</code>
<div class="block">Returns the world unprojected coordinates of a point <code>src</code> defined in the screen coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec)">unprojectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(src, null)</code>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)">unprojectedCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                        <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</code>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(null, src, frame)</code>.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>void</code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()">updateBoundaryEquations</a></strong>()</code>
<div class="block">Updates the boundary plane equations according to the current eye setup, by simply calling
 <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#upVector()">upVector</a></strong>()</code>
<div class="block">Returns the normalized up vector of the Eye, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()">viewDirection</a></strong>()</code>
<div class="block">Returns the normalized view direction of the Eye, defined in the world coordinate system.</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code><a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a></code></td>
<td class="colLast"><code><strong><a href="../../../remixlab/dandelion/core/Eye.html#worldCoordinatesOf(remixlab.dandelion.geom.Vec)">worldCoordinatesOf</a></strong>(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</code>
<div class="block">Returns the world coordinates of the point whose position <code>src</code> is defined in the Eye coordinate system.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a name="methods_inherited_from_class_java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.<a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></h3>
<code><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#getClass()" title="class or interface in java.lang">getClass</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notify()" title="class or interface in java.lang">notify</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#notifyAll()" title="class or interface in java.lang">notifyAll</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#toString()" title="class or interface in java.lang">toString</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait()" title="class or interface in java.lang">wait</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait(long)" title="class or interface in java.lang">wait</a>, <a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#wait(long,%20int)" title="class or interface in java.lang">wait</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<ul class="blockList">
<li class="blockList"><a name="field_detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a name="lastNonFrameUpdate">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>lastNonFrameUpdate</h4>
<pre>public&nbsp;long lastNonFrameUpdate</pre>
<div class="block">Which was the last frame the Eye changes.</div>
</li>
</ul>
</li>
</ul>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<ul class="blockList">
<li class="blockList"><a name="constructor_detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a name="Eye(remixlab.dandelion.core.AbstractScene)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>Eye</h4>
<pre>public&nbsp;Eye(<a href="../../../remixlab/dandelion/core/AbstractScene.html" title="class in remixlab.dandelion.core">AbstractScene</a>&nbsp;scn)</pre>
</li>
</ul>
</li>
</ul>
<!-- ============ METHOD DETAIL ========== -->
<ul class="blockList">
<li class="blockList"><a name="method_detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a name="hashCode()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hashCode</h4>
<pre>public&nbsp;int&nbsp;hashCode()</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#hashCode()" title="class or interface in java.lang">hashCode</a></code>&nbsp;in class&nbsp;<code><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></code></dd>
</dl>
</li>
</ul>
<a name="equals(java.lang.Object)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equals</h4>
<pre>public&nbsp;boolean&nbsp;equals(<a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a>&nbsp;obj)</pre>
<dl>
<dt><strong>Overrides:</strong></dt>
<dd><code><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true#equals(java.lang.Object)" title="class or interface in java.lang">equals</a></code>&nbsp;in class&nbsp;<code><a href="http://java.sun.com/javase/7/docs/api/java/lang/Object.html?is-external=true" title="class or interface in java.lang">Object</a></code></dd>
</dl>
</li>
</ul>
<a name="get()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>get</h4>
<pre>public abstract&nbsp;<a href="../../../remixlab/dandelion/core/Eye.html" title="class in remixlab.dandelion.core">Eye</a>&nbsp;get()</pre>
<div class="block"><strong>Description copied from interface:&nbsp;<code><a href="../../../remixlab/util/Copyable.html#get()">Copyable</a></code></strong></div>
<div class="block">Returns a deep copy of the object.
 <p>
 Typical implementation should simple look like: <code>return new Object(this)</code>.</div>
<dl>
<dt><strong>Specified by:</strong></dt>
<dd><code><a href="../../../remixlab/util/Copyable.html#get()">get</a></code>&nbsp;in interface&nbsp;<code><a href="../../../remixlab/util/Copyable.html" title="interface in remixlab.util">Copyable</a></code></dd>
</dl>
</li>
</ul>
<a name="frame()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frame</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core">InteractiveEyeFrame</a>&nbsp;frame()</pre>
<div class="block">Returns the InteractiveEyeFrame attached to the Eye.
 <p>
 This InteractiveEyeFrame defines its <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> and can translate bogus events
 into Eye displacement. Set using <a href="../../../remixlab/dandelion/core/Eye.html#setFrame(remixlab.dandelion.core.InteractiveEyeFrame)"><code>setFrame(InteractiveEyeFrame)</code></a>.</div>
</li>
</ul>
<a name="distanceToSceneCenter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceToSceneCenter</h4>
<pre>public abstract&nbsp;float&nbsp;distanceToSceneCenter()</pre>
<div class="block">Returns the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> distance in Scene units.
 <p>
 3D Cameras return the projected Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> distance along the Camera Z axis
 and use it in <a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a> and <a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a> to
 optimize the Z range.</div>
</li>
</ul>
<a name="distanceToAnchor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceToAnchor</h4>
<pre>public abstract&nbsp;float&nbsp;distanceToAnchor()</pre>
<div class="block">Returns the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> distance in Scene units.
 <p>
 3D Cameras return the projected Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> distance along the Camera Z axis and
 use it in <a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryWidthHeight(float[])"><code>getBoundaryWidthHeight(float[])</code></a> so that when the Camera is translated forward then its frustum
 is narrowed, making the object appear bigger on screen, as intuitively expected.</div>
</li>
</ul>
<a name="orientation()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>orientation</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Rotation.html" title="interface in remixlab.dandelion.geom">Rotation</a>&nbsp;orientation()</pre>
<div class="block">Returns the Eye orientation, defined in the world coordinate system.
 <p>
 Actually returns <code>frame().orientation()</code>. Use <a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec)"><code>setUpVector(Vec)</code></a> or
 <a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a> to set the Eye orientation.</div>
</li>
</ul>
<a name="lastUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastUpdate</h4>
<pre>public&nbsp;long&nbsp;lastUpdate()</pre>
<div class="block">Max between <a href="../../../remixlab/dandelion/core/Frame.html#lastUpdate()"><code>Frame.lastUpdate()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#lastNonFrameUpdate()"><code>lastNonFrameUpdate()</code></a>.</div>
<dl><dt><span class="strong">Returns:</span></dt><dd>last frame the Eye was updated</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#lastNonFrameUpdate()"><code>lastNonFrameUpdate()</code></a></dd></dl>
</li>
</ul>
<a name="lastNonFrameUpdate()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lastNonFrameUpdate</h4>
<pre>public&nbsp;long&nbsp;lastNonFrameUpdate()</pre>
<dl><dt><span class="strong">Returns:</span></dt><dd>last frame a local Eye parameter (different than the Frame) was updated.</dd><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#lastUpdate()"><code>lastUpdate()</code></a></dd></dl>
</li>
</ul>
<a name="flip()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flip</h4>
<pre>public&nbsp;void&nbsp;flip()</pre>
<div class="block">Same as <code>scene.flip()</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/AbstractScene.html#flip()"><code>AbstractScene.flip()</code></a></dd></dl>
</li>
</ul>
<a name="setFrame(remixlab.dandelion.core.InteractiveEyeFrame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFrame</h4>
<pre>public final&nbsp;void&nbsp;setFrame(<a href="../../../remixlab/dandelion/core/InteractiveEyeFrame.html" title="class in remixlab.dandelion.core">InteractiveEyeFrame</a>&nbsp;icf)</pre>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a>.
 <p>
 If you want to move the Eye, use <a href="../../../remixlab/dandelion/core/Eye.html#setPosition(remixlab.dandelion.geom.Vec)"><code>setPosition(Vec)</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a> or one of the Eye
 positioning methods (<a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()"><code>showEntireScene()</code></a>...) instead.
 <p>
 This method is actually mainly useful if you derive the InteractiveEyeFrame class and want to use an instance of
 your new class to move the Eye.
 <p>
 A <code>null</code> <code>icf</code> reference will silently be ignored.</div>
</li>
</ul>
<a name="lookAt(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>lookAt</h4>
<pre>public abstract&nbsp;void&nbsp;lookAt(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;target)</pre>
<div class="block">2D Windows simply call <code>frame().setPosition(target.x(), target.y())</code>. 3D Cameras set <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>,
 so that it looks at point <code>target</code> defined in the world coordinate system (The Camera <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> is
 not modified. Simply <a href="../../../remixlab/dandelion/core/Camera.html#setViewDirection(remixlab.dandelion.geom.Vec)"><code>Camera.setViewDirection(Vec)</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#at()"><code>at()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec)"><code>setUpVector(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()"><code>showEntireScene()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#fitBoundingBox(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>fitBoundingBox(Vec, Vec)</code></a></dd></dl>
</li>
</ul>
<a name="spinningSensitivity()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>spinningSensitivity</h4>
<pre>public final&nbsp;float&nbsp;spinningSensitivity()</pre>
<div class="block">Convenience wrapper function that simply returns <code>frame().spinningSensitivity()</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#spinningSensitivity()"><code>InteractiveFrame.spinningSensitivity()</code></a></dd></dl>
</li>
</ul>
<a name="setSpinningSensitivity(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSpinningSensitivity</h4>
<pre>public final&nbsp;void&nbsp;setSpinningSensitivity(float&nbsp;sensitivity)</pre>
<div class="block">Convenience wrapper function that simply calls <code>frame().setSpinningSensitivity(sensitivity)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#setSpinningSensitivity(float)"><code>InteractiveFrame.setSpinningSensitivity(float)</code></a></dd></dl>
</li>
</ul>
<a name="rotationSensitivity()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rotationSensitivity</h4>
<pre>public final&nbsp;float&nbsp;rotationSensitivity()</pre>
<div class="block">Convenience wrapper function that simply returns <code>frame().rotationSensitivity()</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#rotationSensitivity()"><code>InteractiveFrame.rotationSensitivity()</code></a></dd></dl>
</li>
</ul>
<a name="setRotationSensitivity(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRotationSensitivity</h4>
<pre>public final&nbsp;void&nbsp;setRotationSensitivity(float&nbsp;sensitivity)</pre>
<div class="block">Convenience wrapper function that simply calls <code>frame().setRotationSensitivity(sensitivity)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#setRotationSensitivity(float)"><code>InteractiveFrame.setRotationSensitivity(float)</code></a></dd></dl>
</li>
</ul>
<a name="translationSensitivity()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>translationSensitivity</h4>
<pre>public final&nbsp;float&nbsp;translationSensitivity()</pre>
<div class="block">Convenience wrapper function that simply returns <code>frame().translationSensitivity()</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#translationSensitivity()"><code>InteractiveFrame.translationSensitivity()</code></a></dd></dl>
</li>
</ul>
<a name="setTranslationSensitivity(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setTranslationSensitivity</h4>
<pre>public final&nbsp;void&nbsp;setTranslationSensitivity(float&nbsp;sensitivity)</pre>
<div class="block">Convenience wrapper function that simply calls <code>frame().setTranslationSensitivity(sensitivity)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/InteractiveFrame.html#setTranslationSensitivity(float)"><code>InteractiveFrame.setTranslationSensitivity(float)</code></a></dd></dl>
</li>
</ul>
<a name="position()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>position</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;position()</pre>
<div class="block">Returns the Eye position, defined in the world coordinate system.
 <p>
 Use <a href="../../../remixlab/dandelion/core/Eye.html#setPosition(remixlab.dandelion.geom.Vec)"><code>setPosition(Vec)</code></a> to set the Eye position. Other convenient methods are showEntireScene() or
 fitSphere(). Actually returns <a href="../../../remixlab/dandelion/core/Frame.html#position()"><code>Frame.position()</code></a>.</div>
</li>
</ul>
<a name="setPosition(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setPosition</h4>
<pre>public&nbsp;void&nbsp;setPosition(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;pos)</pre>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> (the eye), defined in the world coordinate system.</div>
</li>
</ul>
<a name="upVector()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>upVector</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;upVector()</pre>
<div class="block">Returns the normalized up vector of the Eye, defined in the world coordinate system.
 <p>
 Set using <a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec)"><code>setUpVector(Vec)</code></a> or <a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a>. It is orthogonal to
 <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a> and to <a href="../../../remixlab/dandelion/core/Eye.html#rightVector()"><code>rightVector()</code></a>.
 <p>
 It corresponds to the Y axis of the associated <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a> (actually returns <code>frame().yAxis()</code></div>
</li>
</ul>
<a name="setUpVector(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpVector</h4>
<pre>public&nbsp;void&nbsp;setUpVector(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;up)</pre>
<div class="block">Convenience function that simply calls <code>setUpVector(up, true)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec,%20boolean)"><code>setUpVector(Vec, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setUpVector(remixlab.dandelion.geom.Vec, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setUpVector</h4>
<pre>public abstract&nbsp;void&nbsp;setUpVector(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;up,
               boolean&nbsp;noMove)</pre>
<div class="block">Rotates the Eye so that its <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a> becomes <code>up</code> (defined in the world coordinate system).
 <p>
 The Eye is rotated around an axis orthogonal to <code>up</code> and to the current <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a> direction.
 <p>
 Use this method in order to define the Eye horizontal plane.
 <p>
 When <code>noMove</code> is set to <code>false</code>, the orientation modification is compensated by a translation, so that
 the <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> stays projected at the same position on screen. This is especially useful when the Eye is an
 observer of the scene (default action binding).
 <p>
 When <code>noMove</code> is true, the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> is left unchanged, which is an intuitive behavior when the
 Eye is in first person mode.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a></dd></dl>
</li>
</ul>
<a name="rightVector()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rightVector</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;rightVector()</pre>
<div class="block">Returns the normalized right vector of the Eye, defined in the world coordinate system.
 <p>
 This vector lies in the Eye horizontal plane, directed along the X axis (orthogonal to <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a> and to
 <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a>. Set using <a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec)"><code>setUpVector(Vec)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a> or
 <a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a>.
 <p>
 Simply returns <code>frame().xAxis()</code>.</div>
</li>
</ul>
<a name="setOrientation(remixlab.dandelion.geom.Rotation)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setOrientation</h4>
<pre>public abstract&nbsp;void&nbsp;setOrientation(<a href="../../../remixlab/dandelion/geom/Rotation.html" title="interface in remixlab.dandelion.geom">Rotation</a>&nbsp;q)</pre>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>, defined in the world coordinate system.</div>
</li>
</ul>
<a name="sceneRadius()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneRadius</h4>
<pre>public&nbsp;float&nbsp;sceneRadius()</pre>
<div class="block">Returns the radius of the scene observed by the Eye in scene (world) units.
 <p>
 In the case of a 3D Eye (a Camera) you need to provide such an approximation of the scene dimensions so that the it
 can adapt its <a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a> and <a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a>
 values. See the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> documentation.
 <p>
 Note that <a href="../../../remixlab/dandelion/core/AbstractScene.html#radius()"><code>AbstractScene.radius()</code></a> (resp.
 <a href="../../../remixlab/dandelion/core/AbstractScene.html#setRadius(float)"><code>AbstractScene.setRadius(float)</code></a> simply call this method on its associated Eye.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setSceneBoundingBox(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>setSceneBoundingBox(Vec, Vec)</code></a></dd></dl>
</li>
</ul>
<a name="setSceneRadius(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSceneRadius</h4>
<pre>public&nbsp;void&nbsp;setSceneRadius(float&nbsp;radius)</pre>
<div class="block">Sets the <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a> value in scene (world) units. Negative values are ignored. It also sets
 <a href="../../../remixlab/dandelion/core/Eye.html#flySpeed()"><code>flySpeed()</code></a> to 1% of <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a>
 <p>
 <b>Attention:</b> 3d Camera also sets <a href="../../../remixlab/dandelion/core/Camera.html#focusDistance()"><code>Camera.focusDistance()</code></a> to
 <code>sceneRadius() / tan(fieldOfView()/2)</code>.</div>
</li>
</ul>
<a name="setSceneBoundingBox(remixlab.dandelion.geom.Vec, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSceneBoundingBox</h4>
<pre>public abstract&nbsp;void&nbsp;setSceneBoundingBox(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;min,
                       <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;max)</pre>
<div class="block">Similar to <a href="../../../remixlab/dandelion/core/Eye.html#setSceneRadius(float)"><code>setSceneRadius(float)</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenter(remixlab.dandelion.geom.Vec)"><code>setSceneCenter(Vec)</code></a>, but the scene limits are defined by a
 (world axis aligned) bounding box.</div>
</li>
</ul>
<a name="flySpeed()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>flySpeed</h4>
<pre>public&nbsp;float&nbsp;flySpeed()</pre>
<div class="block">Returns the fly speed of the Eye.
 <p>
 Simply returns <code>frame().flySpeed()</code>. See the <a href="../../../remixlab/dandelion/core/InteractiveFrame.html#flySpeed()"><code>InteractiveFrame.flySpeed()</code></a>
 documentation. This value is only meaningful when the action binding is MOVE_FORWARD or is MOVE_BACKWARD.
 <p>
 Set to 0.5% of the <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a> by <a href="../../../remixlab/dandelion/core/Eye.html#setSceneRadius(float)"><code>setSceneRadius(float)</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setFlySpeed(float)"><code>setFlySpeed(float)</code></a></dd></dl>
</li>
</ul>
<a name="setFlySpeed(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setFlySpeed</h4>
<pre>public&nbsp;void&nbsp;setFlySpeed(float&nbsp;speed)</pre>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#flySpeed()"><code>flySpeed()</code></a>.
 <p>
 <b>Attention:</b> This value is modified by <a href="../../../remixlab/dandelion/core/Eye.html#setSceneRadius(float)"><code>setSceneRadius(float)</code></a>.</div>
</li>
</ul>
<a name="setSceneCenterFromPixel(remixlab.dandelion.geom.Point)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSceneCenterFromPixel</h4>
<pre>public abstract&nbsp;boolean&nbsp;setSceneCenterFromPixel(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</pre>
<div class="block">The <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> is set to the point located under <code>pixel</code> on screen.
 <p>
 2D windows always returns true.
 <p>
 3D Cameras returns <code>true</code> if a point was found under <code>pixel</code> and <code>false</code> if none was found (in
 this case no <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> is set).</div>
</li>
</ul>
<a name="sceneCenter()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sceneCenter</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;sceneCenter()</pre>
<div class="block">Returns the position of the scene center, defined in the world coordinate system.
 <p>
 The scene observed by the Eye should be roughly centered on this position, and included in a <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a>
 ball.
 <p>
 Default value is the world origin. Use <a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenter(remixlab.dandelion.geom.Vec)"><code>setSceneCenter(Vec)</code></a> to change it.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setSceneBoundingBox(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>setSceneBoundingBox(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a>, 
<a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a></dd></dl>
</li>
</ul>
<a name="setSceneCenter(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setSceneCenter</h4>
<pre>public&nbsp;void&nbsp;setSceneCenter(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center)</pre>
<div class="block">Sets the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>.
 <p>
 <b>Attention:</b> This method also sets the <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> to <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>.</div>
</li>
</ul>
<a name="anchor()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anchor</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;anchor()</pre>
<div class="block">The point the Eye revolves around with the ROTATE action binding. Defined in world coordinate system.
 <p>
 Default value is the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>.
 <p>
 <b>Attention:</b> <a href="../../../remixlab/dandelion/core/Eye.html#setSceneCenter(remixlab.dandelion.geom.Vec)"><code>setSceneCenter(Vec)</code></a> changes this value.</div>
</li>
</ul>
<a name="setAnchor(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAnchor</h4>
<pre>public&nbsp;void&nbsp;setAnchor(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;rap)</pre>
<div class="block">Changes the <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> to <code>rap</code> (defined in the world coordinate system).</div>
</li>
</ul>
<a name="setAnchorFromPixel(remixlab.dandelion.geom.Point)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAnchorFromPixel</h4>
<pre>public abstract&nbsp;boolean&nbsp;setAnchorFromPixel(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</pre>
<div class="block">The <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> is set to the point located under <code>pixel</code> on screen.
 <p>
 2D windows always returns true.
 <p>
 3D Cameras returns <code>true</code> if a point was found under <code>pixel</code> and <code>false</code> if none was found (in
 this case no <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a> is set).</div>
</li>
</ul>
<a name="aspectRatio()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>aspectRatio</h4>
<pre>public&nbsp;float&nbsp;aspectRatio()</pre>
<div class="block">Returns the Eye aspect ratio defined by <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> / <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a>.
 <p>
 When the Eye is attached to a Scene, these values and hence the aspectRatio() are automatically fitted to the
 viewer's window aspect ratio using setScreenWidthAndHeight().</div>
</li>
</ul>
<a name="setAspectRatio(float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setAspectRatio</h4>
<pre>public&nbsp;void&nbsp;setAspectRatio(float&nbsp;aspect)</pre>
<div class="block">Defines the Eye <a href="../../../remixlab/dandelion/core/Eye.html#aspectRatio()"><code>aspectRatio()</code></a>.
 <p>
 This value is actually inferred from the <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> / <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a> ratio. You should use
 <a href="../../../remixlab/dandelion/core/Eye.html#setScreenWidthAndHeight(int,%20int)"><code>setScreenWidthAndHeight(int, int)</code></a> instead.
 <p>
 This method might however be convenient when the Eye is not associated with a Scene. It actually sets the
 <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a> to 100 and the <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> accordingly.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Camera.html#setFOVToFitScene()"><code>Camera.setFOVToFitScene()</code></a></dd></dl>
</li>
</ul>
<a name="setScreenWidthAndHeight(int, int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setScreenWidthAndHeight</h4>
<pre>public&nbsp;void&nbsp;setScreenWidthAndHeight(int&nbsp;width,
                           int&nbsp;height)</pre>
<div class="block">Sets Eye <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a> (expressed in pixels).
 <p>
 You should not call this method when the Eye is associated with a Scene, since the latter automatically updates
 these values when it is resized (hence overwriting your values).
 <p>
 Non-positive dimension are silently replaced by a 1 pixel value to ensure boundary coherence.
 <p>
 If your Eye is used without a Scene (offscreen rendering, shadow maps), use <a href="../../../remixlab/dandelion/core/Eye.html#setAspectRatio(float)"><code>setAspectRatio(float)</code></a> instead
 to define the projection matrix.</div>
</li>
</ul>
<a name="screenWidth()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>screenWidth</h4>
<pre>public final&nbsp;int&nbsp;screenWidth()</pre>
<div class="block">Returns the width (in pixels) of the Eye screen.
 <p>
 Set using <a href="../../../remixlab/dandelion/core/Eye.html#setScreenWidthAndHeight(int,%20int)"><code>setScreenWidthAndHeight(int, int)</code></a>. This value is automatically fitted to the Scene's window
 dimensions when the Eye is attached to a Scene.</div>
</li>
</ul>
<a name="screenHeight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>screenHeight</h4>
<pre>public final&nbsp;int&nbsp;screenHeight()</pre>
<div class="block">Returns the height (in pixels) of the Eye screen.
 <p>
 Set using <a href="../../../remixlab/dandelion/core/Eye.html#setScreenWidthAndHeight(int,%20int)"><code>setScreenWidthAndHeight(int, int)</code></a>. This value is automatically fitted to the Scene's window
 dimensions when the Eye is attached to a Scene.</div>
</li>
</ul>
<a name="getProjection()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProjection</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getProjection()</pre>
<div class="block">Convenience function that simply returns <code>getProjectionMatrix(false)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getProjection(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProjection</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getProjection(boolean&nbsp;recompute)</pre>
<div class="block">Convenience function that simply returns <code>getProjection(new Mat(), recompute)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getProjection(remixlab.dandelion.geom.Mat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProjection</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getProjection(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m)</pre>
<div class="block">Convenience function that simply returns <code>getProjection(m, false)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getProjection(remixlab.dandelion.geom.Mat, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getProjection</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getProjection(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m,
                boolean&nbsp;recompute)</pre>
<div class="block">Fills <code>m</code> with the Eye projection matrix values and returns it. If <code>m</code> is <code>null</code> a new Mat will
 be created.
 <p>
 If <code>recompute</code> is <code>true</code> first calls <a href="../../../remixlab/dandelion/core/Eye.html#computeProjection()"><code>computeProjection()</code></a> to define the Eye projection matrix.
 Otherwise it returns the projection matrix previously computed, e.g., as with
 <a href="../../../remixlab/dandelion/core/MatrixHelper.html#loadProjection()"><code>MatrixHelper.loadProjection()</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat,%20boolean)"><code>getView(Mat, boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/MatrixHelper.html#loadProjection()"><code>MatrixHelper.loadProjection()</code></a>, 
<a href="../../../remixlab/dandelion/core/MatrixHelper.html#loadModelView()"><code>MatrixHelper.loadModelView()</code></a></dd></dl>
</li>
</ul>
<a name="setProjection(remixlab.dandelion.geom.Mat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setProjection</h4>
<pre>public&nbsp;void&nbsp;setProjection(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;proj)</pre>
<div class="block">Fills the projection matrix with the <code>proj</code> matrix values.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[])"><code>setProjection(float[])</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[],%20boolean)"><code>setProjection(float[], boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setProjection(float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setProjection</h4>
<pre>public&nbsp;void&nbsp;setProjection(float[]&nbsp;source)</pre>
<div class="block">Convenience function that simply calls <code>setProjectionMatrix(source, false)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(remixlab.dandelion.geom.Mat)"><code>setProjection(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[],%20boolean)"><code>setProjection(float[], boolean)</code></a></dd></dl>
</li>
</ul>
<a name="setProjection(float[], boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setProjection</h4>
<pre>public&nbsp;void&nbsp;setProjection(float[]&nbsp;source,
                 boolean&nbsp;transpose)</pre>
<div class="block">Fills the projection matrix with the <code>source</code> matrix values (defined in row-major order).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(remixlab.dandelion.geom.Mat)"><code>setProjection(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setProjection(float[])"><code>setProjection(float[])</code></a></dd></dl>
</li>
</ul>
<a name="computeProjection()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeProjection</h4>
<pre>public abstract&nbsp;void&nbsp;computeProjection()</pre>
<div class="block">Computes the projection matrix associated with the Eye.
 <p>
 If Eye is a 3D PERSPECTIVE Camera, defines a projection matrix using the
 <a href="../../../remixlab/dandelion/core/Camera.html#fieldOfView()"><code>Camera.fieldOfView()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#aspectRatio()"><code>aspectRatio()</code></a>,
 <a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a> and <a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a> parameters. If Eye
 is a 3D ORTHOGRAPHIC Camera, the frustum's width and height are set using <a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryWidthHeight()"><code>getBoundaryWidthHeight()</code></a>. Both
 types use <a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a> and <a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a> to place
 clipping planes. These values are determined from sceneRadius() and sceneCenter() so that they best fit the scene
 size.
 <p>
 Use <a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a> to retrieve this matrix.
 <p>
 <b>Note:</b> You must call this method if your Eye is not associated with a Scene and is used for offscreen
 computations (using <code>projectedCoordinatesOf()</code> for instance).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#setProjection(remixlab.dandelion.geom.Mat)"><code>setProjection(Mat)</code></a></dd></dl>
</li>
</ul>
<a name="getBoundaryWidthHeight()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBoundaryWidthHeight</h4>
<pre>public&nbsp;float[]&nbsp;getBoundaryWidthHeight()</pre>
<div class="block">Convenience function that simply returns <code>getOrthoWidthHeight(new
 float[2])</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryWidthHeight(float[])"><code>getBoundaryWidthHeight(float[])</code></a></dd></dl>
</li>
</ul>
<a name="getBoundaryWidthHeight(float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBoundaryWidthHeight</h4>
<pre>public&nbsp;float[]&nbsp;getBoundaryWidthHeight(float[]&nbsp;target)</pre>
<div class="block">Fills in <code>target</code> with the <code>halfWidth</code> and <code>halfHeight</code> of the Eye boundary and returns it. While
 <code>target[0]</code> holds <code>halfWidth</code>, <code>target[1]</code> holds <code>halfHeight</code>. Values are computed as:
 <code>target[0] = rescalingOrthoFactor() * (frame().magnitude() * this.screenWidth() / 2)</code> and
 <code>rescalingOrthoFactor() * (frame().magnitude() * this.screenHeight() / 2)</code>.
 <p>
 These values are valid for 2d Windows and ortho Cameras (but not persp) and they are expressed in virtual scene
 units.
 <p>
 In the case of ortho Cameras these values are proportional to the Camera (z projected) distance to the
 <a href="../../../remixlab/dandelion/core/Eye.html#anchor()"><code>anchor()</code></a>. When zooming on the object, the Camera is translated forward and its boundary is narrowed,
 making the object appear bigger on screen, as intuitively expected.
 <p>
 Overload this method to change this behavior if desired.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#rescalingOrthoFactor()"><code>rescalingOrthoFactor()</code></a></dd></dl>
</li>
</ul>
<a name="eyeCoordinatesOf(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>eyeCoordinatesOf</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;eyeCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Returns the Eye frame coordinates of a point <code>src</code> defined in world coordinates.
 <p>
 <a href="../../../remixlab/dandelion/core/Eye.html#worldCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>worldCoordinatesOf(Vec)</code></a> performs the inverse transformation.
 <p>
 Note that the point coordinates are simply converted in a different coordinate system. They are not projected on
 screen. Use <a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a> for that.</div>
</li>
</ul>
<a name="worldCoordinatesOf(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>worldCoordinatesOf</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;worldCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Returns the world coordinates of the point whose position <code>src</code> is defined in the Eye coordinate system.
 <p>
 <a href="../../../remixlab/dandelion/core/Eye.html#eyeCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>eyeCoordinatesOf(Vec)</code></a> performs the inverse transformation.</div>
</li>
</ul>
<a name="computeView()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeView</h4>
<pre>public abstract&nbsp;void&nbsp;computeView()</pre>
<div class="block">Computes the View matrix associated with the Eye's <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>.
 <p>
 This matrix converts from the world coordinates system to the Eye coordinates system, so that coordinates can then
 be projected on screen using the projection matrix (see <a href="../../../remixlab/dandelion/core/Eye.html#computeProjection()"><code>computeProjection()</code></a>).
 <p>
 Use <a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a> to retrieve this matrix.
 <p>
 <b>Note:</b> You must call this method if your Eye is not associated with a Scene and is used for offscreen
 computations (using <code>projectedCoordinatesOf()</code> for instance).</div>
</li>
</ul>
<a name="getView()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getView</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getView()</pre>
<div class="block">Convenience function that simply returns <code>getViewMatrix(false)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getView(boolean)"><code>getView(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat)"><code>getView(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat,%20boolean)"><code>getView(Mat, boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(boolean)"><code>getProjection(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat)"><code>getProjection(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getView(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getView</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getView(boolean&nbsp;recompute)</pre>
<div class="block">Convenience function that simply returns <code>getViewMatrix(new Mat(), recompute)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat)"><code>getView(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat,%20boolean)"><code>getView(Mat, boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(boolean)"><code>getProjection(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat)"><code>getProjection(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getView(remixlab.dandelion.geom.Mat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getView</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getView(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m)</pre>
<div class="block">Convenience function that simply returns <code>getViewMatrix(m, false)</code></div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(boolean)"><code>getView(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat,%20boolean)"><code>getView(Mat, boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(boolean)"><code>getProjection(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat)"><code>getProjection(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="getView(remixlab.dandelion.geom.Mat, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getView</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;getView(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;m,
          boolean&nbsp;recompute)</pre>
<div class="block">Fills <code>m</code> with the Eye View matrix values and returns it. If <code>m</code> is <code>null</code> a new Mat will be
 created.
 <p>
 If <code>recompute</code> is <code>true</code> first calls <a href="../../../remixlab/dandelion/core/Eye.html#computeView()"><code>computeView()</code></a> to define the Eye view matrix. Otherwise it
 returns the view matrix previously computed, e.g., as with
 <a href="../../../remixlab/dandelion/core/MatrixHelper.html#loadModelView()"><code>MatrixHelper.loadModelView()</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(boolean)"><code>getView(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getView(remixlab.dandelion.geom.Mat)"><code>getView(Mat)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(boolean)"><code>getProjection(boolean)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getProjection(remixlab.dandelion.geom.Mat,%20boolean)"><code>getProjection(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="fromView(remixlab.dandelion.geom.Mat)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromView</h4>
<pre>public&nbsp;void&nbsp;fromView(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;mv)</pre>
<div class="block">Convenience function that simply calls <code>fromView(mv, true)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#fromView(remixlab.dandelion.geom.Mat,%20boolean)"><code>fromView(Mat, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="fromView(remixlab.dandelion.geom.Mat, boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fromView</h4>
<pre>public abstract&nbsp;void&nbsp;fromView(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;mv,
            boolean&nbsp;recompute)</pre>
<div class="block">Sets the Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> from an OpenGL-like View matrix.
 <p>
 After this method has been called, <a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a> returns a matrix equivalent to <code>mv</code>. Only the
 <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> of the Eye are modified.</div>
</li>
</ul>
<a name="projectedCoordinatesOf(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;projectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(src, null)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a></dd></dl>
</li>
</ul>
<a name="projectedCoordinatesOf(remixlab.dandelion.geom.Mat, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;projectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projview,
                         <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(projview, src, null)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a></dd></dl>
</li>
</ul>
<a name="projectedCoordinatesOf(remixlab.dandelion.geom.Vec, remixlab.dandelion.core.Frame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;projectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                         <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</pre>
<div class="block">Convenience function that simply returns <code>projectedCoordinatesOf(null, src, frame)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a></dd></dl>
</li>
</ul>
<a name="projectedCoordinatesOf(remixlab.dandelion.geom.Mat, remixlab.dandelion.geom.Vec, remixlab.dandelion.core.Frame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>projectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;projectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projview,
                         <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                         <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</pre>
<div class="block">Returns the screen projected coordinates of a point <code>src</code> defined in the <code>frame</code> coordinate system.
 <p>
 When <code>frame</code> is <code>null</code>, <code>src</code> is expressed in the world coordinate system. See
 <a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>projectedCoordinatesOf(Vec)</code></a>.
 <p>
 The x and y coordinates of the returned Vec are expressed in pixel, (0,0) being the upper left corner of the
 window. The z coordinate ranges between 0.0 (near plane) and 1.0 (excluded, far plane). See the <code>gluProject</code>
 man page for details.
 <p>
 Use <a href="../../../remixlab/dandelion/core/AbstractScene.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec)"><code>AbstractScene.projectedCoordinatesOf(Vec)</code></a> which is simpler and has been
 optimized by caching the Projection x View matrix.
 <p>
 <b>Attention:</b> This method only uses the intrinsic Eye parameters (see <a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#getViewport()"><code>getViewport()</code></a>) and is completely independent of the processing matrices. You
 can hence define a virtual Eye and use this method to compute projections out of a classical rendering context.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>unprojectedCoordinatesOf(Vec, Frame)</code></a></dd></dl>
</li>
</ul>
<a name="unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unprojectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;unprojectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(src, null)</code>.
 
 #see <a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>unprojectedCoordinatesOf(Vec, Frame)</code></a></div>
</li>
</ul>
<a name="unprojectedCoordinatesOf(remixlab.dandelion.geom.Mat, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unprojectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;unprojectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projviewInv,
                           <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src)</pre>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(projviewInv, src, null)</code>.
 
 #see <a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>unprojectedCoordinatesOf(Vec, Frame)</code></a></div>
</li>
</ul>
<a name="unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec, remixlab.dandelion.core.Frame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unprojectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;unprojectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                           <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</pre>
<div class="block">Convenience function that simply returns <code>unprojectedCoordinatesOf(null, src, frame)</code>.
 
 #see <a href="../../../remixlab/dandelion/core/Eye.html#unprojectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>unprojectedCoordinatesOf(Vec, Frame)</code></a></div>
</li>
</ul>
<a name="unprojectedCoordinatesOf(remixlab.dandelion.geom.Mat, remixlab.dandelion.geom.Vec, remixlab.dandelion.core.Frame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unprojectedCoordinatesOf</h4>
<pre>public final&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;unprojectedCoordinatesOf(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projviewInv,
                           <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;src,
                           <a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;frame)</pre>
<div class="block">Returns the world unprojected coordinates of a point <code>src</code> defined in the screen coordinate system.
 <p>
 The <code>src.x</code> and <code>src.y</code> input values are expressed in pixels, (0,0) being the upper left corner of the
 window. The <code>src.z</code> is a depth value ranging in [0..1] (near and far plane respectively). In 3D Note that
 <code>src.z</code> is not a linear interpolation between <a href="../../../remixlab/dandelion/core/Camera.html#zNear()"><code>Camera.zNear()</code></a> and
 <a href="../../../remixlab/dandelion/core/Camera.html#zFar()"><code>Camera.zFar()</code></a>; <code>src.z = zFar() / (zFar() - zNear()) * (1.0f - zNear() / z);</code>
 where <code>z</code> is the distance from the point you project to the camera, along the <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a> . See
 the <code>gluUnProject</code> man page for details.
 <p>
 The result is expressed in the <code>frame</code> coordinate system. When <code>frame</code> is <code>null</code>, the result is
 expressed in the world coordinates system. The possible <code>frame</code> hierarchy (i.e., when
 <a href="../../../remixlab/dandelion/core/Frame.html#referenceFrame()"><code>Frame.referenceFrame()</code></a> is non-null) is taken into account.
 <p>
 <a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a> performs the inverse transformation.
 <p>
 This method only uses the intrinsic Eye parameters (see <a href="../../../remixlab/dandelion/core/Eye.html#getView()"><code>getView()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#getProjection()"><code>getProjection()</code></a> and
 <a href="../../../remixlab/dandelion/core/Eye.html#getViewport()"><code>getViewport()</code></a>) and is completely independent of the Processing matrices. You can hence define a virtual
 Eye and use this method to compute un-projections out of a classical rendering context.
 <p>
 <b>Attention:</b> However, if your Eye is not attached to a Scene (used for offscreen computations for instance),
 make sure the Eye matrices are updated before calling this method (use <a href="../../../remixlab/dandelion/core/Eye.html#computeView()"><code>computeView()</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.html#computeProjection()"><code>computeProjection()</code></a>).
 <p>
 This method is not computationally optimized. If you call it several times with no change in the matrices, you
 should buffer the entire inverse projection matrix (view, projection and then viewport) to speed-up the queries.
 See the gluUnProject man page for details.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#projectedCoordinatesOf(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.core.Frame)"><code>projectedCoordinatesOf(Vec, Frame)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setScreenWidthAndHeight(int,%20int)"><code>setScreenWidthAndHeight(int, int)</code></a></dd></dl>
</li>
</ul>
<a name="getViewport()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getViewport</h4>
<pre>public&nbsp;int[]&nbsp;getViewport()</pre>
<div class="block">Convenience function that simply calls <code>return</code> <a href="../../../remixlab/dandelion/core/Eye.html#getViewport(int[])"><code>getViewport(int[])</code></a>.</div>
</li>
</ul>
<a name="getViewport(int[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getViewport</h4>
<pre>public&nbsp;int[]&nbsp;getViewport(int[]&nbsp;vp)</pre>
<div class="block">Fills <code>viewport</code> with the Eye viewport and returns it. If viewport is null (or not the correct size), a new
 array will be created.
 <p>
 This method is mainly used in conjunction with <code>project(float, float, float, Mat, Mat, int[], float[])</code> ,
 which requires such a viewport. Returned values are (0, <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#screenWidth()"><code>screenWidth()</code></a>, -
 <a href="../../../remixlab/dandelion/core/Eye.html#screenHeight()"><code>screenHeight()</code></a>), so that the origin is located in the upper left corner of the window.</div>
</li>
</ul>
<a name="project(float, float, float, float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>project</h4>
<pre>public&nbsp;boolean&nbsp;project(float&nbsp;objx,
              float&nbsp;objy,
              float&nbsp;objz,
              float[]&nbsp;windowCoordinate)</pre>
<div class="block">Similar to <code>gluProject</code>: map object coordinates to window coordinates.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>objx</code> - Specify the object x coordinate.</dd><dd><code>objy</code> - Specify the object y coordinate.</dd><dd><code>objz</code> - Specify the object z coordinate.</dd><dd><code>windowCoordinate</code> - Return the computed window coordinates.</dd></dl>
</li>
</ul>
<a name="project(remixlab.dandelion.geom.Mat, float, float, float, float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>project</h4>
<pre>public&nbsp;boolean&nbsp;project(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projectionViewMat,
              float&nbsp;objx,
              float&nbsp;objy,
              float&nbsp;objz,
              float[]&nbsp;windowCoordinate)</pre>
</li>
</ul>
<a name="unproject(float, float, float, float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unproject</h4>
<pre>public&nbsp;boolean&nbsp;unproject(float&nbsp;winx,
                float&nbsp;winy,
                float&nbsp;winz,
                float[]&nbsp;objCoordinate)</pre>
</li>
</ul>
<a name="unproject(remixlab.dandelion.geom.Mat, float, float, float, float[])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>unproject</h4>
<pre>public&nbsp;boolean&nbsp;unproject(<a href="../../../remixlab/dandelion/geom/Mat.html" title="class in remixlab.dandelion.geom">Mat</a>&nbsp;projectionViewInverseMat,
                float&nbsp;winx,
                float&nbsp;winy,
                float&nbsp;winz,
                float[]&nbsp;objCoordinate)</pre>
<div class="block">Similar to <code>gluUnProject</code>: map window coordinates to object coordinates.</div>
<dl><dt><span class="strong">Parameters:</span></dt><dd><code>projectionViewInverseMat</code> - Specify the cached (projection * modelvview)^1 matrix.</dd><dd><code>winx</code> - Specify the window x coordinate.</dd><dd><code>winy</code> - Specify the window y coordinate.</dd><dd><code>winz</code> - Specify the window z coordinate.</dd><dd><code>objCoordinate</code> - Return the computed object coordinates.</dd></dl>
</li>
</ul>
<a name="keyFrameInterpolatorMap()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>keyFrameInterpolatorMap</h4>
<pre>public&nbsp;<a href="http://java.sun.com/javase/7/docs/api/java/util/HashMap.html?is-external=true" title="class or interface in java.util">HashMap</a>&lt;<a href="http://java.sun.com/javase/7/docs/api/java/lang/Integer.html?is-external=true" title="class or interface in java.lang">Integer</a>,<a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>&gt;&nbsp;keyFrameInterpolatorMap()</pre>
</li>
</ul>
<a name="keyFrameInterpolatorArray()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>keyFrameInterpolatorArray</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>[]&nbsp;keyFrameInterpolatorArray()</pre>
</li>
</ul>
<a name="keyFrameInterpolator(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>keyFrameInterpolator</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>&nbsp;keyFrameInterpolator(int&nbsp;key)</pre>
<div class="block">Returns the KeyFrameInterpolator that defines the Eye path number <code>key</code>.
 <p>
 The returned KeyFrameInterpolator may be null (if no path is defined for key <code>key</code>).</div>
</li>
</ul>
<a name="setKeyFrameInterpolator(int, remixlab.dandelion.core.KeyFrameInterpolator)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setKeyFrameInterpolator</h4>
<pre>public&nbsp;void&nbsp;setKeyFrameInterpolator(int&nbsp;key,
                           <a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html" title="class in remixlab.dandelion.core">KeyFrameInterpolator</a>&nbsp;keyFInterpolator)</pre>
<div class="block">Sets the KeyFrameInterpolator that defines the Eye path of index <code>key</code>.</div>
</li>
</ul>
<a name="addKeyFrameToPath(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>addKeyFrameToPath</h4>
<pre>public&nbsp;void&nbsp;addKeyFrameToPath(int&nbsp;key)</pre>
<div class="block">Adds the current Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> as a keyFrame to path <code>key</code>. If
 <code>editablePath</code> is <code>true</code>, builds an InteractiveFrame (from the current Eye <a href="../../../remixlab/dandelion/core/Eye.html#position()"><code>position()</code></a> and
 <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a>) before adding it (see
 <a href="../../../remixlab/dandelion/core/InteractiveFrame.html#InteractiveFrame(remixlab.dandelion.core.AbstractScene,%20remixlab.dandelion.core.InteractiveEyeFrame)"><code>InteractiveFrame.InteractiveFrame(AbstractScene, InteractiveEyeFrame)</code></a> ). In the
 latter mode the resulting created path will be editable.
 <p>
 This method can also be used if you simply want to save an Eye point of view (a path made of a single keyFrame).
 Use <a href="../../../remixlab/dandelion/core/Eye.html#playPath(int)"><code>playPath(int)</code></a> to make the Eye play the keyFrame path (resp. restore the point of view). Use
 <a href="../../../remixlab/dandelion/core/Eye.html#deletePath(int)"><code>deletePath(int)</code></a> to clear the path.
 <p>
 The default keyboard shortcuts for this method are keys [1-5].
 <p>
 If you use directly this method and the <a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int)</code></a> does not exist, a new one is created.</div>
</li>
</ul>
<a name="playPath(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>playPath</h4>
<pre>public&nbsp;void&nbsp;playPath(int&nbsp;key)</pre>
<div class="block">Makes the Eye follow the path of keyFrameInterpolator() number <code>key</code>.
 <p>
 If the interpolation is started, it stops it instead.
 <p>
 This method silently ignores undefined (empty) paths (see keyFrameInterpolator()).
 <p>
 The default keyboard shortcuts for this method are keys [1-5].</div>
</li>
</ul>
<a name="deletePath(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>deletePath</h4>
<pre>public&nbsp;void&nbsp;deletePath(int&nbsp;key)</pre>
<div class="block">Deletes the <a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int)</code></a> of index <code>key</code>.</div>
</li>
</ul>
<a name="resetPath(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>resetPath</h4>
<pre>public&nbsp;void&nbsp;resetPath(int&nbsp;key)</pre>
<div class="block">Resets the path of the <a href="../../../remixlab/dandelion/core/Eye.html#keyFrameInterpolator(int)"><code>keyFrameInterpolator(int)</code></a> number <code>key</code>.
 <p>
 If this path is not being played (see <a href="../../../remixlab/dandelion/core/Eye.html#playPath(int)"><code>playPath(int)</code></a> and
 <a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html#interpolationStarted()"><code>KeyFrameInterpolator.interpolationStarted()</code></a>), resets it to its starting position
 (see <a href="../../../remixlab/dandelion/core/KeyFrameInterpolator.html#resetInterpolation()"><code>KeyFrameInterpolator.resetInterpolation()</code></a>). If the path is played, simply
 stops interpolation.</div>
</li>
</ul>
<a name="anyInterpolationStarted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyInterpolationStarted</h4>
<pre>public&nbsp;boolean&nbsp;anyInterpolationStarted()</pre>
<div class="block">Returns <code>true</code> if any interpolation associated with this Eye is currently being performed (and <code>false</code>
 otherwise).</div>
</li>
</ul>
<a name="anyInterpolationIsStarted()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>anyInterpolationIsStarted</h4>
<pre><a href="http://java.sun.com/javase/7/docs/api/java/lang/Deprecated.html?is-external=true" title="class or interface in java.lang">@Deprecated</a>
public&nbsp;boolean&nbsp;anyInterpolationIsStarted()</pre>
<div class="block"><span class="strong">Deprecated.</span>&nbsp;<i>Please refrain from using this method, it will be removed from future releases.</i></div>
<div class="block">Use <a href="../../../remixlab/dandelion/core/Eye.html#anyInterpolationStarted()"><code>anyInterpolationStarted()</code></a> instead.</div>
</li>
</ul>
<a name="stopAllInterpolations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>stopAllInterpolations</h4>
<pre>public&nbsp;void&nbsp;stopAllInterpolations()</pre>
<div class="block">Stops all interpolations currently being performed associated with this Eye.</div>
</li>
</ul>
<a name="computeBoundaryEquations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeBoundaryEquations</h4>
<pre>public abstract&nbsp;float[][]&nbsp;computeBoundaryEquations()</pre>
<div class="block">Convenience function that in 2D simply returns <code>computeFrustumPlanesCoefficients(new float [4][3])</code> and in 3D
 <code>computeFrustumPlanesCoefficients(new float [6][4])</code>.
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you need the frustum equations to be updated
 only occasionally (rare). Use <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a> which
 automatically update the frustum equations every frame instead.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations(float[][])"><code>computeBoundaryEquations(float[][])</code></a></dd></dl>
</li>
</ul>
<a name="computeBoundaryEquations(float[][])">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>computeBoundaryEquations</h4>
<pre>public abstract&nbsp;float[][]&nbsp;computeBoundaryEquations(float[][]&nbsp;coef)</pre>
<div class="block">Fills <code>coef</code> with the 6 plane equations of the camera frustum and returns it.
 <p>
 In 2D the four 4-component vectors of <code>coef</code> respectively correspond to the left, right, top and bottom
 Window boundary lines. Each vector holds a plane equation of the form:
 <p>
 <code>a*x + b*y + c = 0</code> where <code>a</code>, <code>b</code> and <code>c</code> are the 3 components of each vector, in that
 order.
 <p>
 <p>
 In 3D the six 4-component vectors of <code>coef</code> respectively correspond to the left, right, near, far, top and
 bottom Camera frustum planes. Each vector holds a plane equation of the form:
 <p>
 <code>a*x + b*y + c*z + d = 0</code>
 <p>
 where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of each vector, in that order.
 <p>
 This format is compatible with the <code>gl.glClipPlane()</code> function. One camera frustum plane can hence be applied
 in an other viewer to visualize the culling results:
 <p>
 <code>// Retrieve place equations</code><br>
 <code>float [][] coef =
 mainViewer.camera().getFrustumPlanesCoefficients();</code><br>
 <code>// These two additional clipping planes (which must have been enabled)</code><br>
 <code>// will reproduce the mainViewer's near and far clipping.</code><br>
 <code>gl.glClipPlane(GL.GL_CLIP_PLANE0, coef[2]);</code><br>
 <code>gl.glClipPlane(GL.GL_CLIP_PLANE1, coef[3]);</code><br>
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you need the frustum equations to be updated
 only occasionally (rare). Use <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a> which
 automatically update the frustum equations every frame instead.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="enableBoundaryEquations(boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>enableBoundaryEquations</h4>
<pre>public&nbsp;void&nbsp;enableBoundaryEquations(boolean&nbsp;flag)</pre>
<div class="block">Enables or disables automatic update of the eye boundary plane equations every frame according to <code>flag</code>.
 Computation of the equations is expensive and hence is disabled by default.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="areBoundaryEquationsEnabled()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>areBoundaryEquationsEnabled</h4>
<pre>public&nbsp;boolean&nbsp;areBoundaryEquationsEnabled()</pre>
<div class="block">Returns <code>true</code> if automatic update of the eye boundary plane equations is enabled and <code>false</code>
 otherwise. Computation of the equations is expensive and hence is disabled by default.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="updateBoundaryEquations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>updateBoundaryEquations</h4>
<pre>public&nbsp;void&nbsp;updateBoundaryEquations()</pre>
<div class="block">Updates the boundary plane equations according to the current eye setup, by simply calling
 <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>.
 <p>
 <b>Attention:</b> You should not call this method explicitly, unless you need the boundary equations to be updated
 only occasionally (rare). Use <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a> which
 automatically update the boundary equations every frame instead.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)"><code>distanceToBoundary(int, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()"><code>getBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="getBoundaryEquations()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>getBoundaryEquations</h4>
<pre>public&nbsp;float[][]&nbsp;getBoundaryEquations()</pre>
<div class="block">Returns the boundary plane equations.
 <p>
 The six 4-component vectors returned by this method, respectively correspond to the left, right, near, far, top and
 bottom Eye boundary planes. Each vector holds a plane equation of the form:
 <p>
 <code>a*x + b*y + c*z + d = 0</code>
 <p>
 where <code>a</code>, <code>b</code>, <code>c</code> and <code>d</code> are the 4 components of each vector, in that order.
 <p>
 <b>Attention:</b> The eye boundary plane equations should be updated before calling this method. You may compute
 them explicitly (by calling <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a> ) or enable them to be automatic updated in your
 Scene setup (with <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)"><code>distanceToBoundary(int, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="distanceToBoundary(int, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>distanceToBoundary</h4>
<pre>public&nbsp;float&nbsp;distanceToBoundary(int&nbsp;index,
                       <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;pos)</pre>
<div class="block">Returns the signed distance between point <code>pos</code> and plane <code>index</code> in Scene units. The distance is
 negative if the point lies in the planes's boundary halfspace, and positive otherwise.
 <p>
 <code>index</code> is a value between <code>0</code> and <code>5</code> which respectively correspond to the left, right, near,
 far, top and bottom Eye boundary planes.
 <p>
 <b>Attention:</b> The eye boundary plane equations should be updated before calling this method. You may compute
 them explicitly (by calling <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a> ) or enable them to be automatic updated in your
 Scene setup (with <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()"><code>getBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="isPointVisible(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isPointVisible</h4>
<pre>public abstract&nbsp;boolean&nbsp;isPointVisible(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;point)</pre>
<div class="block">Returns <code>true</code> if <code>point</code> is visible (i.e, lies within the Eye boundary) and <code>false</code> otherwise.
 <p>
 <b>Attention:</b> The Eye boundary plane equations should be updated before calling this method. You may compute
 them explicitly (by calling <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a> ) or enable them to be automatic updated in your
 Scene setup (with <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)"><code>distanceToBoundary(int, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()"><code>getBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="ballVisibility(remixlab.dandelion.geom.Vec, float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ballVisibility</h4>
<pre>public abstract&nbsp;<a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core">Eye.Visibility</a>&nbsp;ballVisibility(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center,
                            float&nbsp;radius)</pre>
<div class="block">Returns <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#VISIBLE"><code>Eye.Visibility.VISIBLE</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#INVISIBLE"><code>Eye.Visibility.INVISIBLE</code></a>, or
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#SEMIVISIBLE"><code>Eye.Visibility.SEMIVISIBLE</code></a>, depending whether the sphere (of radius <code>radius</code>
 and center <code>center</code>) is visible, invisible, or semi-visible, respectively.
 <p>
 <b>Attention:</b> The Eye boundary plane equations should be updated before calling this method. You may compute
 them explicitly (by calling <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a> ) or enable them to be automatic updated in your
 Scene setup (with <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)"><code>distanceToBoundary(int, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#boxVisibility(remixlab.dandelion.geom.Vec,%20remixlab.dandelion.geom.Vec)"><code>boxVisibility(Vec, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()"><code>getBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="boxVisibility(remixlab.dandelion.geom.Vec, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>boxVisibility</h4>
<pre>public abstract&nbsp;<a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core">Eye.Visibility</a>&nbsp;boxVisibility(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;p1,
                           <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;p2)</pre>
<div class="block">Returns <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#VISIBLE"><code>Eye.Visibility.VISIBLE</code></a>,
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#INVISIBLE"><code>Eye.Visibility.INVISIBLE</code></a>, or
 <a href="../../../remixlab/dandelion/core/Eye.Visibility.html#SEMIVISIBLE"><code>Eye.Visibility.SEMIVISIBLE</code></a>, depending whether the axis aligned box (defined by
 corners <code>p1</code> and <code>p2</code>) is visible, invisible, or semi-visible, respectively.
 <p>
 <b>Attention:</b> The Eye boundary plane equations should be updated before calling this method. You may compute
 them explicitly (by calling <a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a> ) or enable them to be automatic updated in your
 Scene setup (with <a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a>).</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#distanceToBoundary(int,%20remixlab.dandelion.geom.Vec)"><code>distanceToBoundary(int, Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#isPointVisible(remixlab.dandelion.geom.Vec)"><code>isPointVisible(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#ballVisibility(remixlab.dandelion.geom.Vec,%20float)"><code>ballVisibility(Vec, float)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#computeBoundaryEquations()"><code>computeBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#updateBoundaryEquations()"><code>updateBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#getBoundaryEquations()"><code>getBoundaryEquations()</code></a>, 
<a href="../../../remixlab/dandelion/core/AbstractScene.html#enableBoundaryEquations()"><code>AbstractScene.enableBoundaryEquations()</code></a></dd></dl>
</li>
</ul>
<a name="pixelSceneRatio(remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pixelSceneRatio</h4>
<pre>public abstract&nbsp;float&nbsp;pixelSceneRatio(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;position)</pre>
<div class="block">Returns the ratio between pixel and scene units at <code>position</code>.
 <p>
 A line of <code>n * pixelSceneRatio()</code> scene units, located at <code>position</code> in the world coordinates system,
 will be projected with a length of <code>n</code> pixels on screen.
 <p>
 Use this method to scale objects so that they have a constant pixel size on screen. The following code will draw a
 20 pixel line, starting at <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> and always directed along the screen vertical direction:
 <p>
 <code>beginShape(LINES);</code><br>
 <code>vertex(sceneCenter().x, sceneCenter().y, sceneCenter().z);</code><br>
 <code>Vec v = Vec.add(sceneCenter(), Vec.mult(upVector(), 20 * pixelSceneRatio(sceneCenter())));</code><br>
 <code>vertex(v.x, v.y, v.z);</code><br>
 <code>endShape();</code><br></div>
</li>
</ul>
<a name="interpolateToZoomOnRegion(remixlab.dandelion.geom.Rect)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateToZoomOnRegion</h4>
<pre>public&nbsp;void&nbsp;interpolateToZoomOnRegion(<a href="../../../remixlab/dandelion/geom/Rect.html" title="class in remixlab.dandelion.geom">Rect</a>&nbsp;rectangle)</pre>
<div class="block">Smoothly moves the Eye so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin
 in the upper left corner) fits the screen.
 <p>
 The Eye is translated (its <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> is unchanged) so that <code>rectangle</code> is entirely visible.
 Since the pixel coordinates only define a <i>boundary</i> in 3D, it's the intersection of this boundary with a
 plane (orthogonal to the <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a> and passing through the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>) that is used to
 define the 3D rectangle that is eventually fitted.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#fitScreenRegion(remixlab.dandelion.geom.Rect)"><code>fitScreenRegion(Rect)</code></a></dd></dl>
</li>
</ul>
<a name="interpolateToFitScene()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateToFitScene</h4>
<pre>public&nbsp;void&nbsp;interpolateToFitScene()</pre>
<div class="block">Interpolates the Eye on a one second KeyFrameInterpolator path so that the entire scene fits the screen at the end.
 <p>
 The scene is defined by its <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> and its <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a>. See <a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()"><code>showEntireScene()</code></a>.
 <p>
 The <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> of the Eye is not modified.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#interpolateToZoomOnPixel(remixlab.dandelion.geom.Point)"><code>interpolateToZoomOnPixel(Point)</code></a></dd></dl>
</li>
</ul>
<a name="interpolateTo(remixlab.dandelion.core.Frame)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateTo</h4>
<pre>public&nbsp;void&nbsp;interpolateTo(<a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;fr)</pre>
<div class="block">Convenience function that simply calls <code>interpolateTo(fr, 1)</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#interpolateTo(remixlab.dandelion.core.Frame,%20float)"><code>interpolateTo(Frame, float)</code></a></dd></dl>
</li>
</ul>
<a name="interpolateTo(remixlab.dandelion.core.Frame, float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>interpolateTo</h4>
<pre>public&nbsp;void&nbsp;interpolateTo(<a href="../../../remixlab/dandelion/core/Frame.html" title="class in remixlab.dandelion.core">Frame</a>&nbsp;fr,
                 float&nbsp;duration)</pre>
<div class="block">Smoothly interpolates the Eye on a KeyFrameInterpolator path so that it goes to <code>fr</code>.
 <p>
 <code>fr</code> is expressed in world coordinates. <code>duration</code> tunes the interpolation speed.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#interpolateTo(remixlab.dandelion.core.Frame)"><code>interpolateTo(Frame)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#interpolateToFitScene()"><code>interpolateToFitScene()</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#interpolateToZoomOnPixel(remixlab.dandelion.geom.Point)"><code>interpolateToZoomOnPixel(Point)</code></a></dd></dl>
</li>
</ul>
<a name="fitBall(remixlab.dandelion.geom.Vec, float)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitBall</h4>
<pre>public abstract&nbsp;void&nbsp;fitBall(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;center,
           float&nbsp;radius)</pre>
<div class="block">Moves the Eye so that the ball defined by <code>center</code> and <code>radius</code> is visible and fits the window.
 <p>
 In 3D the Camera is simply translated along its <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a> so that the sphere fits the screen. Its
 <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> and its <a href="../../../remixlab/dandelion/core/Camera.html#fieldOfView()"><code>Camera.fieldOfView()</code></a> are unchanged. You should
 therefore orientate the Camera before you call this method.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a>, 
<a href="../../../remixlab/dandelion/core/Eye.html#setUpVector(remixlab.dandelion.geom.Vec,%20boolean)"><code>setUpVector(Vec, boolean)</code></a></dd></dl>
</li>
</ul>
<a name="fitBoundingBox(remixlab.dandelion.geom.Vec, remixlab.dandelion.geom.Vec)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitBoundingBox</h4>
<pre>public abstract&nbsp;void&nbsp;fitBoundingBox(<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;min,
                  <a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;max)</pre>
<div class="block">Moves the Eye so that the (world axis aligned) bounding box (<code>min</code> , <code>max</code>) is entirely visible, using
 <a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a>.</div>
</li>
</ul>
<a name="fitScreenRegion(remixlab.dandelion.geom.Rect)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fitScreenRegion</h4>
<pre>public abstract&nbsp;void&nbsp;fitScreenRegion(<a href="../../../remixlab/dandelion/geom/Rect.html" title="class in remixlab.dandelion.geom">Rect</a>&nbsp;rectangle)</pre>
<div class="block">Moves the Eye so that the rectangular screen region defined by <code>rectangle</code> (pixel units, with origin in the
 upper left corner) fits the screen.
 <p>
 in 3D the Camera is translated (its <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> is unchanged) so that <code>rectangle</code> is entirely
 visible. Since the pixel coordinates only define a <i>frustum</i> in 3D, it's the intersection of this frustum with
 a plane (orthogonal to the <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a> and passing through the <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>) that is used to
 define the 3D rectangle that is eventually fitted.</div>
</li>
</ul>
<a name="showEntireScene()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>showEntireScene</h4>
<pre>public abstract&nbsp;void&nbsp;showEntireScene()</pre>
<div class="block">Moves the Eye so that the entire scene is visible.
 <p>
 Simply calls <a href="../../../remixlab/dandelion/core/Eye.html#fitBall(remixlab.dandelion.geom.Vec,%20float)"><code>fitBall(Vec, float)</code></a> on a sphere defined by <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> and <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a>.
 <p>
 You will typically use this method at init time after you defined a new <a href="../../../remixlab/dandelion/core/Eye.html#sceneRadius()"><code>sceneRadius()</code></a>.</div>
</li>
</ul>
<a name="centerScene()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>centerScene</h4>
<pre>public&nbsp;void&nbsp;centerScene()</pre>
<div class="block">Moves the Eye so that its <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a> is projected on the center of the window. The
 <a href="../../../remixlab/dandelion/core/Eye.html#orientation()"><code>orientation()</code></a> (and in the case of perps 3d <a href="../../../remixlab/dandelion/core/Camera.html#fieldOfView()"><code>Camera.fieldOfView()</code></a>) is (are)
 unchanged.
 <p>
 Simply projects the current position on a line passing through <a href="../../../remixlab/dandelion/core/Eye.html#sceneCenter()"><code>sceneCenter()</code></a>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#showEntireScene()"><code>showEntireScene()</code></a></dd></dl>
</li>
</ul>
<a name="viewDirection()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>viewDirection</h4>
<pre>public&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;viewDirection()</pre>
<div class="block">Returns the normalized view direction of the Eye, defined in the world coordinate system. This corresponds to the
 negative Z axis of the <a href="../../../remixlab/dandelion/core/Eye.html#frame()"><code>frame()</code></a> ( <code>frame().inverseTransformOf(new Vec(0.0f, 0.0f, -1.0f))</code> ) whih in
 2D always is (0,0,-1)
 <p>
 In 3D change this value using <a href="../../../remixlab/dandelion/core/Camera.html#setViewDirection(remixlab.dandelion.geom.Vec)"><code>Camera.setViewDirection(Vec)</code></a>, <a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a> or
 <a href="../../../remixlab/dandelion/core/Eye.html#setOrientation(remixlab.dandelion.geom.Rotation)"><code>setOrientation(Rotation)</code></a> . It is orthogonal to <a href="../../../remixlab/dandelion/core/Eye.html#upVector()"><code>upVector()</code></a> and to <a href="../../../remixlab/dandelion/core/Eye.html#rightVector()"><code>rightVector()</code></a>.</div>
</li>
</ul>
<a name="at()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>at</h4>
<pre>public abstract&nbsp;<a href="../../../remixlab/dandelion/geom/Vec.html" title="class in remixlab.dandelion.geom">Vec</a>&nbsp;at()</pre>
<div class="block">2D Windows return the postion. 3D Cameras return a point defined in the world coordinate system where the camera is
 pointing at (just in front of <a href="../../../remixlab/dandelion/core/Eye.html#viewDirection()"><code>viewDirection()</code></a>). Useful for setting the Processing camera() which uses a
 similar approach of that found in gluLookAt.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#lookAt(remixlab.dandelion.geom.Vec)"><code>lookAt(Vec)</code></a></dd></dl>
</li>
</ul>
<a name="interpolateToZoomOnPixel(remixlab.dandelion.geom.Point)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>interpolateToZoomOnPixel</h4>
<pre>public abstract&nbsp;void&nbsp;interpolateToZoomOnPixel(<a href="../../../remixlab/dandelion/geom/Point.html" title="class in remixlab.dandelion.geom">Point</a>&nbsp;pixel)</pre>
<div class="block">Makes the Eye smoothly zoom on the <a href="../../../remixlab/dandelion/core/Camera.html#pointUnderPixel(remixlab.dandelion.geom.Point)"><code>Camera.pointUnderPixel(Point)</code></a> <code>pixel</code> and
 returns the world coordinates of the <a href="../../../remixlab/dandelion/core/Camera.html#pointUnderPixel(remixlab.dandelion.geom.Point)"><code>Camera.pointUnderPixel(Point)</code></a>.
 <p>
 In 3D nothing happens if no <a href="../../../remixlab/dandelion/core/Camera.html#pointUnderPixel(remixlab.dandelion.geom.Point)"><code>Camera.pointUnderPixel(Point)</code></a> is found. Otherwise a
 KeyFrameInterpolator is created that animates the Camera on a one second path that brings the Camera closer to the
 point under <code>pixel</code>.</div>
<dl><dt><span class="strong">See Also:</span></dt><dd><a href="../../../remixlab/dandelion/core/Eye.html#interpolateToFitScene()"><code>interpolateToFitScene()</code></a></dd></dl>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<!-- ========= END OF CLASS DATA ========= -->
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a name="navbar_bottom">
<!--   -->
</a><a href="#skip-navbar_bottom" title="Skip navigation links"></a><a name="navbar_bottom_firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="../../../overview-summary.html">Overview</a></li>
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../../../deprecated-list.html">Deprecated</a></li>
<li><a href="../../../index-all.html">Index</a></li>
<li><a href="../../../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList">
<li><a href="../../../remixlab/dandelion/core/Constants.WheelAction.html" title="enum in remixlab.dandelion.core"><span class="strong">Prev Class</span></a></li>
<li><a href="../../../remixlab/dandelion/core/Eye.Visibility.html" title="enum in remixlab.dandelion.core"><span class="strong">Next Class</span></a></li>
</ul>
<ul class="navList">
<li><a href="../../../index.html?remixlab/dandelion/core/Eye.html" target="_top">Frames</a></li>
<li><a href="Eye.html" target="_top">No Frames</a></li>
</ul>
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../../../allclasses-noframe.html">All Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li><a href="#nested_class_summary">Nested</a>&nbsp;|&nbsp;</li>
<li><a href="#field_summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field_detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor_detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method_detail">Method</a></li>
</ul>
</div>
<a name="skip-navbar_bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
<p class="legalCopy"><small>Processing library proscene by Jean Pierre Charalambos. (c) 2014</small></p>
</body>
</html>
