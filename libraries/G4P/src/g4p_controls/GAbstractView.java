package g4p_controls;

import g4p_controls.HotSpot.HSrect;
import processing.core.PApplet;
import processing.core.PConstants;
import processing.core.PGraphics;
import processing.event.Event;
import processing.event.MouseEvent;

public abstract class GAbstractView extends GAbstractControl  implements PConstants, GConstantsInternal {

	protected PApplet papplet = null;
	protected PGraphics view = null;
	protected boolean is3D = false;
	
	// This object will handle mouse events
	protected GViewListener viewListener = null;

	// Mouse state data
	protected int pmouseX, pmouseY;
	protected int mouseX, mouseY;
	protected int button;
	protected int count;
	protected int modifiers;

	boolean mousePressed = false;

	// Is the mouse over the control now, and was it over in previous frame?
	boolean isOver = false;
	boolean pisOver = false;

	/**
	 * Constructor - call this from child class
	 * @param theApplet  the main sketch 
	 * @param p0 x position based on control mode
	 * @param p1 y position based on control mode
	 * @param p2 x position or width based on control mode
	 * @param p3 y position or height based on control mode
	 * @param p3 y position or height based on control mode
	 */
	public GAbstractView(PApplet theApplet, float p0, float p1, float p2, float p3) {
		super(theApplet, p0, p1, p2, p3);
		hotspots = new HotSpot[]{
				new HSrect(1, 0, 0, width, height)		// drawing surface
		};
	}
	
	/**
	 * Get the PGrahics canvas for this view. The returned value should be cast 
	 * to Graphics3D if view is 3D (i.e. uses P3D) <br>
	 * @return the graphics context to draw on 
	 */
	final public PGraphics getGraphics() {
		return view;
	}

	public PGraphics getSnapshot(){
		if(view != null){
			return (PGraphics) view.get();
		}
		return null;
	}
	
	/**
	 * Returns true if the view is 3D
	 */
	final boolean is3D() {
		return is3D;
	}
	
	/**
	 * Converts the event generated by Processing into one relative to 
	 * the view control.
	 * @param event the mouse event generated by Processing
	 * @param action the action to be used in the converted event
	 * @param x mouse X position relative to top-left corner of the view
	 * @param y mouse Y position relative to top-left corner of the view
	 * @return the converted event
	 */
	protected MouseEvent convertEvent(MouseEvent event, int action, float x, float y) {
		// Store previous mouse positions
		pmouseX = mouseX;
		pmouseY = mouseY;
		// Get event details and update them
		mouseX = PApplet.constrain((int) x, 0, width() - 1);
		mouseY = PApplet.constrain((int) y, 0, height() - 1);
		button = event.getButton();
		count = event.getCount();
		if(action == MouseEvent.PRESS || action == MouseEvent.DRAG) {
			mousePressed = true;
		}
		else if(action == MouseEvent.RELEASE) {
			mousePressed = false;
		}
		modifiers = event.getModifiers();
		// Create new event based on this info
		return new MouseEvent(event.getNative(),
				event.getMillis(),
				action,
				event.getModifiers(),
				mouseX, 
				mouseY,
				button,
				count
				);
	}

	/**
	 * Is the shift key down?
	 */
	final boolean isShiftDown() {
		return (modifiers & Event.SHIFT) != 0;
	}

	/**
	 * Is the shift ctrl down?
	 */
	final boolean isControlDown() {
		return (modifiers & Event.CTRL) != 0;
	}

	/**
	 * Is the meta key down?
	 */
	final boolean isMetaDown() {
		return (modifiers & Event.META) != 0;
	}

	/**
	 * Is the alt key down?
	 */
	final boolean isAltDown() {
		return (modifiers & Event.ALT) != 0;
	}
	
	final public boolean isOver() {
		return isOver;
	}

	/**
	 * Draw the finished view (PGraphics).
	 * This method is called by G4P after the PApplet's draw() method is executed
	 */
	public void draw(){
		if(!visible) return;

		if(bufferInvalid && viewListener != null) {
				viewListener.update();
		}
		winApp.pushStyle();

		winApp.pushMatrix();
		// Perform the rotation
		winApp.translate(cx, cy);
		winApp.rotate(rotAngle);
		// Move matrix to line up with top-left corner
		winApp.translate(-halfWidth, -halfHeight);
		// Draw buffer
		winApp.imageMode(PApplet.CORNER);
		if(alphaLevel < 255)
			winApp.tint(TINT_FOR_ALPHA, alphaLevel);
		winApp.image(view, 0, 0);	
		winApp.popMatrix();		
		winApp.popStyle();
	}

	/**
	 * Call this method to set the object to handle mouse events for this view.<br>
	 * The object's class should inherit from GViewerListener <br>
	 * @param listener mouse event handler object
	 */
	public void addListener(GViewListener listener) {
		if(viewListener == null) {
			viewListener = listener;
			viewListener.setView(this);
			bufferInvalid = true;
		}
		else {
			System.out.println("You have already added a listener to this GView control");
		}
	}

	/**
	 * Remove the listener. 
	 * @param listener the listener to remove
	 */
	public void removeListener(GViewListener listener) {
		if(viewListener == listener) {
			viewListener = null;
			viewListener.setView(null);
			bufferInvalid = false;
		}
		else {
			System.out.println("The listener does not belong to this GView control");
		}
	}

	/** 
	 * @return the listener for this view.
	 */
	public GViewListener getListener() {
		return viewListener;
	}
	
	/**
	 * @return the top-left corner x position of the view
	 */
	public int x() {
		return (int) x;
	}
	
	/**
	 * @return the top-left corner y position of the view
	 */
	public int y() {
		return (int) y;
	}
	
	/**
	 * @return the width of this view.
	 */
	public int width() {
		return view.width;
	}

	/**
	 * @return the height of this view.
	 */
	public int height() {
		return view.height;
	}


}
